#!/bin/bash

# Output colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

STASH_MESSAGE="auto-stash-before-pull-script"
stashRef=""

currentBranch=$(git symbolic-ref --short HEAD 2>/dev/null)
localBranches=($(git for-each-ref --format='%(refname:short)' refs/heads/))
branchCount=${#localBranches[@]}

# Ensure inside a git repo
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  echo -e "${RED}‚ùå Not a Git repository. Aborting.${NC}"
  exit 1
fi

if [ "$1" == "git-pull-all" ]; then
  #if ! git diff --quiet || ! git diff --cached --quiet; then
  #  echo -e "${YELLOW}üíæ Stashing local changes...${NC}"
  #  stashRef=$(git stash create)
  #  if [ -n "$stashRef" ]; then
  #    git stash store -m "$STASH_MESSAGE" "$stashRef"
  #  fi
  #fi
  echo -e "${GREEN}üì° Fetching all remotes...${NC}"
  if ! git fetch --all --prune; then
    echo -e "${RED}‚ùå Error: Failed to fetch remotes. Check your network or remote URLs.${NC}"
    exit 1
  fi
  if [ -z "$currentBranch" ]; then
    echo -e "${RED}‚ùå Not on a valid branch (detached HEAD?). Aborting.${NC}"
    exit 1
  fi
  echo -e "${GREEN}üîÑ Pulling current branch: ${YELLOW}$currentBranch${NC}"
  if git rev-parse --abbrev-ref --symbolic-full-name @{u} > /dev/null 2>&1; then
    if ! git pull origin "$currentBranch"; then
      echo -e "${RED}‚ùå Failed to pull branch '$currentBranch'. Resolve any conflicts manually.${NC}"
      exit 1
    fi
  else
    echo -e "${YELLOW}‚ö†Ô∏è  Current branch '$currentBranch' has no upstream. Skipping pull.${NC}"
  fi
  if [ "$branchCount" -gt 1 ]; then
    for branch in "${localBranches[@]}"; do
      if [ "$branch" != "$currentBranch" ]; then
        echo -e "${GREEN}‚û°Ô∏è  Switching to branch: ${YELLOW}$branch${NC}"
        if ! git checkout "$branch"; then
          echo -e "${RED}‚ùå Failed to checkout branch '$branch'.${NC}"
          exit 1
        fi
        if git rev-parse --abbrev-ref --symbolic-full-name @{u} > /dev/null 2>&1; then
          echo -e "${GREEN}üîÑ Pulling latest changes for branch: ${YELLOW}$branch${NC}"
          if ! git pull origin "$branch"; then
            echo -e "${RED}‚ùå Failed to pull branch '$branch'.${NC}"
            exit 1
          fi
        else
          echo -e "${YELLOW}‚ö†Ô∏è  Branch '$branch' has no upstream. Skipping pull.${NC}"
        fi
      fi
    done
    echo -e "${GREEN}üîÅ Returning to original branch: ${YELLOW}$currentBranch${NC}"
    git checkout "$currentBranch"
  fi
  #if git stash list | grep -q "$STASH_MESSAGE"; then
  #  echo -e "${YELLOW}üì¶ Re-applying stashed changes...${NC}"
  #  if ! git stash apply; then
  #    echo -e "${RED}‚ùå Conflicts while applying stashed changes. Please resolve manually.${NC}"
  #    echo -e "${YELLOW}üîé Stash still available with label: '${STASH_MESSAGE}'${NC}"
  #    exit 1
  #  else
  #    git stash drop
  #  fi
  #fi
  echo -e "${GREEN}‚úÖ Pull process completed successfully.${NC}"

elif [ "$1" == "git-pull-simple" ]; then
  echo -e "${GREEN}üì° Fetching all remotes...${NC}"
  if ! git fetch --all --prune; then
    echo -e "${RED}‚ùå Error: Failed to fetch remotes. Check your network or remote URLs.${NC}"
    exit 1
  fi
  if [ -z "$currentBranch" ]; then
    echo -e "${RED}‚ùå Not on a valid branch (detached HEAD?). Aborting.${NC}"
    exit 1
  fi
  echo -e "${GREEN}üîÑ Pulling current branch: ${YELLOW}$currentBranch${NC}"
  if git rev-parse --abbrev-ref --symbolic-full-name @{u} > /dev/null 2>&1; then
    if ! git pull origin "$currentBranch"; then
      echo -e "${RED}‚ùå Failed to pull branch '$currentBranch'. Resolve any conflicts manually.${NC}"
      exit 1
    fi
  else
    echo -e "${YELLOW}‚ö†Ô∏è  Current branch '$currentBranch' has no upstream. Skipping pull.${NC}"
  fi
  echo -e "${GREEN}‚úÖ Pull completed on branch '${YELLOW}$currentBranch${GREEN}'.${NC}"

elif [ "$1" == "prune-local" ]; then
  if [ "$branchCount" -gt 1 ]; then
    echo -e "${YELLOW}üßπ Cleaning up local branches except '${currentBranch}'...${NC}"
    for branch in "${localBranches[@]}"; do
      if [ "$branch" != "$currentBranch" ]; then
        echo -e "${GREEN}üóëÔ∏è  Deleting local branch: ${YELLOW}$branch${NC}"
        if ! git branch -D "$branch"; then
          echo -e "${RED}‚ùå Failed to delete branch '$branch'.${NC}"
        fi
      fi
    done
  else
    echo -e "${GREEN}‚úÖ Nothing to prune. Only one local branch '${currentBranch}' found.${NC}"
  fi

elif [ "$1" == "git-amend" ]; then
  if [ -z "$currentBranch" ]; then
    echo "‚ùå Could not determine the current branch."
    exit 1
  fi
  if git diff --quiet && git diff --cached --quiet; then
    echo -e "${YELLOW}‚ÑπÔ∏è No pending changes to commit. Nothing to amend.${NC}"
    exit 0
  fi
  read -p "‚ö†Ô∏è Are you sure you want to force-push the amended commit? (Y/N): " confirm
  if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
    echo -e "${YELLOW}‚ùå Aborted by user.${NC}"
    exit 1
  fi
  if ! git add .; then
    echo -e "${RED}‚ùå Failed to stage files with 'git add'. Check for invalid files or permissions.${NC}"
  exit 1
  fi
  if ! git commit --amend --no-edit; then
    echo -e "${RED}‚ùå Failed to amend the last commit. Ensure you have a commit to amend.${NC}"
  exit 1
  fi
  if ! git push origin "$currentBranch" --force; then
    echo -e "${RED}‚ùå Failed to push changes. Verify your remote or permissions.${NC}"
    exit 1
  fi
  echo -e "${GREEN}‚úÖ Amend and force-push completed successfully on branch '${YELLOW}$currentBranch${GREEN}'.${NC}"

elif [ "$1" == "ignore-files" ]; then
  git ls-files -m | grep -E '\.java$|\.sh$' | xargs git update-index --assume-unchanged

elif [ "$1" == "view-ignored-files" ]; then
  git ls-files -v | grep '^[a-z]'

elif [ "$1" == "view-files-to-ignored" ]; then
  git ls-files -m | grep -E '\.java$|\.sh$'

fi
